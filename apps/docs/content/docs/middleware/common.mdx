---
title: Commons
description: Configure CORS, rate limiting, logging, and timeout middleware on one page.
---

We provide a set of common middleware that you can use to secure your storage API. These middleware are designed to be used together and can be combined to create a secure and efficient storage API.

- [CORS](#cors)
- [Rate Limiting](#rate-limiting)
- [Logging](#logging)
- [Timeout](#timeout)

## CORS

Use `createCorsMiddleware` to handle preflight requests and provide CORS header data. You can find the implementation [here](https://github.com/chris23lngr/vS3/blob/master/packages/vs3/src/middleware/common/cors.ts).

```ts
createCorsMiddleware({
  allowedOrigins: ["https://app.example.com"],
  allowedMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
  maxAge: 86400,
});
```

Notes:

- For `OPTIONS`, middleware responds with `204` and CORS headers.
- For non-preflight requests, it adds CORS data into middleware context.

## Rate Limiting

Set up rate limiting with a store and limits. Users wont be able to upload more than `maxRequests` requests per `windowMs`. A store is required to track requests. We provide an in-memory store for this purpose (Redis support is coming soon).

You can find the implementation [here](https://github.com/chris23lngr/vS3/blob/master/packages/vs3/src/middleware/common/rate-limit.ts).

```ts
const store = createInMemoryRateLimitStore();

createRateLimitMiddleware({
  maxRequests: 100,
  windowMs: 60_000,
  store,
});
```

The default bucket key (used to track requests) is `ctx.path`. You can customize this with `keyGenerator`.

```ts
createRateLimitMiddleware({
  maxRequests: 20,
  windowMs: 60_000,
  store,
  keyGenerator: (ctx) => `${ctx.path}:${resolveClientIp(ctx.headers)}`,
});
```

When limit is exceeded, middleware throws `RATE_LIMIT_EXCEEDED`.

<Callout type="warn" title="Deployment note â€“ proxy headers">
The `x-forwarded-for` header is only trustworthy when the app sits behind a reverse proxy (nginx, Cloudflare, AWS ALB, etc.) that overwrites the header. If clients can reach the server directly, they can spoof the header and bypass rate limits. 

Configure your proxy to strip or overwrite `x-forwarded-for` before it reaches the application.
</Callout>

<Callout type="error" title="Behaviour change">
The behaviour of this middleware will likely change in the near future.
</Callout>

## Logging

Logs each incoming request. You can pass in any logger function that receives a log entry object (`{ method, path, timestamp }`). You can find the implementation [here](https://github.com/chris23lngr/vS3/blob/master/packages/vs3/src/middleware/common/logging.ts).

```ts
createLoggingMiddleware({
  logger: (entry) => {
    myLogger.info(entry);
  },
});
```

## Timeout

Specify a timeout for requests. If the request takes longer than the specified timeout, it will be rejected with a `TIMEOUT` error. Implementation can be found [here](https://github.com/chris23lngr/vS3/blob/master/packages/vs3/src/middleware/common/timeout.ts).

```ts
createTimeoutMiddleware({
  timeoutMs: 30_000,
});
```

The middleware adds `ctx.context.timeout?.signal` to the context which will be consumed by the endpoint handlers.

## Path Filters on Common Middleware

All common middlewares supports path filtering. You can use `skipPaths` to run on all paths except the ones listed, or `includePaths` to run only on the listed paths. They cannot be used together.

```ts
{
  skipPaths?: string[];
  includePaths?: string[];
}
```
